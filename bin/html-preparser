#!/usr/bin/env node

const Emitter = require('events').EventEmitter,
  meow = require('meow'),
  path = require('path'),
  stdout = require('stdout-stream'),
  stdin = require('get-stdin'),
  fs = require('fs');

const cli = meow({
  pkg: ../package.json,
  help: [
    'Usage:',
    '  html-preparser [options] <in.html>',
    '',
    'Example: TODO'
    '',
    'Options:',
    '  -r, --replace        Overwrites the input file',
    '  -o, --output         Output file',
    '  -x, --rules          Instruction file',
    '  -q, --quiet          Suppress log output except on error',
    '  -v, --version        Prints version info',
    '  -h, --help           Print usage info',
    '  --error-bell         Output a bell character on errors'
  ].join('\n')
}, {
  alias: {
    r: 'replace',
    x: 'rules',
    o: 'output',
    v: 'version',
    h: 'help'
  },
  boolean: [
    'error-bell',
    'replace',
    'quiet',
  ],
  string: [
    'output',
    'rules'
  ],
  default: {
    replace: false
  }
})

/**
 * Is a Directory
 *
 * @param {String} filePath
 * @returns {Boolean}
 * @api private
 */

function isDirectory(filePath) {
  let isDir = false;
  try {
    const absolutePath = path.resolve(filePath);
    isDir = fs.statSync(absolutePath).isDirectory();
  } catch (e) {
    isDir = e.code === 'ENOENT';
  }
  return isDir;
}

/**
 * Create emitter
 *
 * @api private
 */

function getEmitter() {
  let emitter = new Emitter();

  emitter.on('error', err => {
    if (options.errorBell) {
      err += '\x07';
    }
    console.error(err);
    process.exit(1);
  });

  emitter.on('warn', data => {
    if (!options.quiet) {
      console.warn(data);
    }
  });

  emitter.on('log', stdout.write.bind(stdout));

  return emitter;
}

/**
 * Construct options
 *
 * @param {Array} arguments
 * @param {Object} options
 * @api private
 */

function getOptions(args, options) {
  options.src = args[0];

  if (!options.rules) {
    options.rules = path.join(
      path.dirname(options.src),
      [path.basename(options.src, path.extname(options.src)), '.json'].join('')
  }

  if (args[1]) {
    options.dest = path.resolve(args[1]);
  } else if (options.output) {
    options.dest = path.join(
      path.resolve(options.output),
      path.basename(options.src));
  }
    
  return options;
}

/**
 * Run
 *
 * @param {Object} options
 * @param {Object} emitter
 * @api private
 */

function run(options, emitter) {
  render(options, emitter);
}

/**
 * Arguments and options
 */

const options = getOptions(cli.input, cli.flags);
const emitter = getEmitter();

/**
 * Show usage if no arguments are supplied
 */

if (!options.src && process.stdin.isTTY) {
  emitter.emit('error', [
    'Provide a html file to render',
    '',
    'Example: Compile src/index.html to dist/index.html',
    '  html-preparser src/index.html > dist/index.html',
    '  cat index.html | html-preparser -x src/index.json > dist/index.html'
  ].join('\n'));
}

/**
 * Apply arguments
 */

if (options.src) {
  run(options, emitter);
} else if (!process.stdin.isTTY) {
  stdin(function(data) {
    options.data = data;
    options.stdin = true;
    run(options, emitter);
  });
}
